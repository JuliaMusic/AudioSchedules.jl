var documenterSearchIndex = {"docs":
[{"location":"#Interface-1","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"#","page":"Interface","title":"Interface","text":"Modules = [AudioSchedules]","category":"page"},{"location":"#","page":"Interface","title":"Interface","text":"Modules = [AudioSchedules]","category":"page"},{"location":"#AudioSchedules.AudioSchedule-Tuple{}","page":"Interface","title":"AudioSchedules.AudioSchedule","text":"AudioSchedule(the_sample_rate)\n\nCreate an AudioSchedule. Add synthesizers to the audio schedule with schedule!, then use Plan to play the schedule.\n\njulia> using AudioSchedules\n\njulia> AudioSchedule()\nAudioSchedule(Tuple{Any,Any,Any}[])\n\n\n\n\n\n","category":"method"},{"location":"#AudioSchedules.Cycles","page":"Interface","title":"AudioSchedules.Cycles","text":"Cycles(frequency)\n\nCycles from 0 to 2π to repeat at a frequency.\n\n\n\n\n\n","category":"type"},{"location":"#AudioSchedules.Envelope","page":"Interface","title":"AudioSchedules.Envelope","text":"Envelope(levels, durations, shapes)\n\nShapes are all functions which return synthesizers:\n\nshape(start_value, end_value, duration) -> synthesizer\n\ndurations and levels list the time and level of the boundaries of segments of the envelope. For example,\n\nEnvelope([0.0, 1.0, 1.0, 0.0], [.05 s, 0.9 s, 0.05 s], [Line, Line, Line])\n\nwill create an envelope with three segments:\n\nLine(0.0, 1.0, 0.05 s)\nLine(1.0, 1.0, 0.9 s)\nLine(1.0, 0.0, 0.05 s)\n\nUse Envelopes with schedule!.\n\njulia> using AudioSchedules\n\njulia> using Unitful: s, Hz\n\njulia> audio_schedule = AudioSchedule();\n\njulia> envelope = Envelope((0.0, 1.0, 0.0), (1s, 1s), (Line, Line));\n\njulia> schedule!(audio_schedule, StrictMap(sin, Cycles(440Hz)), 0s, envelope)\n\njulia> plan = Plan(audio_schedule, 44100Hz);\n\njulia> read(plan, length(plan));\n\nYou can also use compound shapes like Hook.\n\n\n\n\n\n","category":"type"},{"location":"#AudioSchedules.Grow","page":"Interface","title":"AudioSchedules.Grow","text":"Grow(start, rate)\n\nExponentially grow or decay from start, at a continuous rate.\n\n\n\n\n\n","category":"type"},{"location":"#AudioSchedules.Hook","page":"Interface","title":"AudioSchedules.Hook","text":"Hook(rate, slope)\n\nMake a hook shape, with an exponential curve growing at rate, followed by a line with slope. Useful as part as an Envelope.\n\njulia> using AudioSchedules\n\njulia> using Unitful: s, Hz\n\njulia> audio_schedule = AudioSchedule();\n\njulia> envelope = Envelope((0.0, 1.0, 0.0), (0.05s, 0.95s), (Line, Hook(-1/s, -1/0.05s),));\n\njulia> schedule!(audio_schedule, StrictMap(sin, Cycles(440Hz)), 0s, envelope)\n\njulia> plan = plan_within(audio_schedule, 44100Hz);\n\njulia> read(plan, length(plan));\n\nNot all hooks are solvable:\n\njulia> audio_schedule = AudioSchedule();\n\njulia> envelope = Envelope((1.0, 0.0), (1s,), (Hook(1/1s, 0.5/1s),));\n\njulia> schedule!(audio_schedule, StrictMap(sin, Cycles(440Hz)), 0s, envelope)\n\njulia> Plan(audio_schedule, 44100Hz)\nERROR: Unsolvable hook\n\n\n\n\n\n","category":"type"},{"location":"#AudioSchedules.Line","page":"Interface","title":"AudioSchedules.Line","text":"Line(start_value, end_value, duration)\n\nA line from start_value to end_value that lasts for duration.\n\n\n\n\n\n","category":"type"},{"location":"#AudioSchedules.Plan-Tuple{AudioSchedule,Any}","page":"Interface","title":"AudioSchedules.Plan","text":"Plan(audio_schedule::AudioSchedule)\n\nReturn a SampledSource for an AudioSchedule.\n\njulia> using AudioSchedules\n\njulia> using Unitful: s, Hz\n\njulia> audio_schedule = AudioSchedule();\n\njulia> schedule!(audio_schedule, StrictMap(sin, Cycles(440Hz)), 0s, 1s)\n\njulia> plan = Plan(audio_schedule, 44100Hz);\n\nYou can find the number of samples in a Plan with length.\n\njulia> the_length = length(plan)\n44100\n\nYou can use the plan as a source for samples.\n\njulia> read(plan, the_length);\n\nYou can't plan an empty schedule\n\njulia> Plan(AudioSchedule(), 44100Hz)\nERROR: The schedule was empty\n[...]\n\n\n\n\n\n","category":"method"},{"location":"#AudioSchedules.StrictMap","page":"Interface","title":"AudioSchedules.StrictMap","text":"StrictMap(a_function, synthesizers...)\n\nMap a_function over synthesizers, assuming that none of the synthesizers will end before they are scheduled to.\n\n\n\n\n\n","category":"type"},{"location":"#AudioSchedules.compound_wave-Tuple{Any,Any}","page":"Interface","title":"AudioSchedules.compound_wave","text":"compound_wave(overtones, dampen)\n\nCreate a complex wave. Create a function of this form:\n\nangle -> sum((sin(overtone * angle) / overtone^dampen for overtone in 1:overtones))\n\njulia> using AudioSchedules\n\njulia> compound_wave(25, 2)(π/4)\n0.9809432244745053\n\n\n\n\n\n","category":"method"},{"location":"#AudioSchedules.equal_loudness-Tuple{StrictMap{#s41,Tuple{Cycles}} where #s41}","page":"Interface","title":"AudioSchedules.equal_loudness","text":"equal_loudness(synthesizer::StrictMap{<:Any, Tuple{Cycles}})\n\nChange the volume of a synthesizer so that sounds played at different frequencies will have the same perceived volume. Assumes that the map function has a period of 2π.\n\njulia> using AudioSchedules\n\njulia> using Unitful: Hz\n\njulia> soft = equal_loudness(StrictMap(cos, Cycles(10000Hz)));\n\njulia> first(make_iterator(soft, 44100Hz)) ≈ 0.0053035474\ntrue\n\nTechnical details: uses the ISO 226:2003 curve for 40 phons. Scales output by a ratio of the equivalent sound pressure at the current frequency to the equivalent sound pressure at 20Hz (about as low as humans can hear).\n\n\n\n\n\n","category":"method"},{"location":"#AudioSchedules.extrema!-Tuple{Plan}","page":"Interface","title":"AudioSchedules.extrema!","text":"extrema!(plan::Plan)\n\nFind the extrema of a plan. This will consume the plan.\n\njulia> using AudioSchedules\n\njulia> using Unitful: s, Hz\n\njulia> audio_schedule = AudioSchedule();\n\njulia> schedule!(audio_schedule, StrictMap(sin, Cycles(440Hz)), 0s, Envelope((1, 1), (1s,), (Line,)))\n\njulia> extrema!(Plan(audio_schedule, 44100Hz)) .≈ (-0.99999974, 0.99999974)\n(true, true)\n\n\n\n\n\n","category":"method"},{"location":"#AudioSchedules.get_duration-Tuple{SampledSignals.SampleBuf}","page":"Interface","title":"AudioSchedules.get_duration","text":"get_duration(synthesizer)\n\nGet the duration of a synthesizer in seconds, for synthesizers with an inherent length. Note that the synthesizer cannot end during the duration (which means there must be one more sample at the end of the duration).\n\n\n\n\n\n","category":"method"},{"location":"#AudioSchedules.make_iterator-Tuple{SampledSignals.SampleBuf,Any}","page":"Interface","title":"AudioSchedules.make_iterator","text":"make_iterator(synthesizer, the_sample_rate)\n\nReturn an iterator that will the play the synthesizer at the_sample_rate\n\n\n\n\n\n","category":"method"},{"location":"#AudioSchedules.plan_within-Tuple{AudioSchedule,Any}","page":"Interface","title":"AudioSchedules.plan_within","text":"plan_within(audio_schedule::AudioSchedule, the_sample_rate; maximum_volume = 1.0)\n\nMake a plan, then adjust the volume to maximum_volume.\n\njulia> using AudioSchedules\n\njulia> using Unitful: s, Hz\n\njulia> audio_schedule = AudioSchedule();\n\njulia> note = (StrictMap(sin, Cycles(440Hz)), 0s, 1s);\n\njulia> schedule!(audio_schedule, note...); schedule!(audio_schedule, note...)\n\njulia> plan = plan_within(audio_schedule, 44100Hz);\n\njulia> extrema!(plan) .≈ (-1.0, 1.0)\n(true, true)\n\n\n\n\n\n","category":"method"},{"location":"#AudioSchedules.repeat!-Tuple{AudioSchedule,Any,Any,Any,Any}","page":"Interface","title":"AudioSchedules.repeat!","text":"function repeat!(audio_schedule::AudioSchedule, synthesizer, start_time, gap, count)\n\nRepeat the synthesizer, starting at start_time, count times, with gap time between each repeat.\n\njulia> using AudioSchedules\n\njulia> using Unitful: Hz, s\n\njulia> using FileIO: load\n\njulia> import LibSndFile\n\njulia> audio_schedule = AudioSchedule();\n\njulia> cd(joinpath(pkgdir(AudioSchedules), \"test\"))\n\njulia> repeat!(audio_schedule, load(\"clunk.wav\"), 0s, 1s, 5)\n\njulia> plan = Plan(audio_schedule, 44100Hz);\n\njulia> read(plan, length(plan));\n\n\n\n\n\n","category":"method"},{"location":"#AudioSchedules.schedule!","page":"Interface","title":"AudioSchedules.schedule!","text":"schedule!(audio_schedule::AudioSchedule, synthesizer, start_time, duration = get_duration(synthesizer))\nschedule!(audio_schedule::AudioSchedule, synthesizer, start_time, envelope::Envelope)\n\nSchedule an audio synthesizer to be added to the audio_schedule, starting at start_time with duration, or with the duration contained in an Envelope. If no duration is given, use get_duration to determine a duration.\n\njulia> using AudioSchedules\n\njulia> using Unitful: s, Hz\n\njulia> audio_schedule = AudioSchedule();\n\njulia> schedule!(audio_schedule, StrictMap(sin, Cycles(440Hz)), 0s, 1s)\n\n\n\n\n\n","category":"function"},{"location":"#AudioSchedules.@q_str-Tuple{AbstractString}","page":"Interface","title":"AudioSchedules.@q_str","text":"q\"interval\"\n\nCreate a musical interval. You can specify a numerator (which defaults to 1) and denominator (which defaults to 1) and an octave shift (which defaults to 0).\n\njulia> using AudioSchedules\n\njulia> q\"1\"\n1//1\n\njulia> q\"3/2\"\n3//2\n\njulia> q\"2/3o1\"\n4//3\n\njulia> q\"2/3o-1\"\n1//3\n\njulia> q\"o2\"\n4//1\n\n\n\n\n\n","category":"macro"}]
}
